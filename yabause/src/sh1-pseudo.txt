#define RDR0 (*(u8*)(0x5FFFEC5))
#define TDR0 (*(u8*)(0x5FFFEC3))
#define SSR0 (*(u8*)(0x5FFFEC4))

u8 unk_F0002C4[12]; // just a pointer in ram, but is used like an array of 12 bytes
struct // data is at 0x0F0002D0(11 byte structure)
{
   u8 status; // F0002D0
   u8 q; // F0002D1
   u8 track; // F0002D2
   u8 index; // F0002D3
   u16 mmss; // F0002D4
   u8 ff; // F0002D6
   u8 zero_not; // F0002D7
   u8 abs_mm; // F0002D8
   u8 abs_ss; // F0002D9
   u8 abs_ff; // F0002DA
} cd_rx;
#define TRANSFER_STATUS (*(u8*)(0xf0002db))
u8 cd_mech_buff[12]; // data is at 0x0F000304
#define cd_mech_csum (*(u8*)(0xf000310))
#define cd_mech_bytes (*(u8*)(0xf000311))

void vectITU3IMIB3()
{
   // interrupt when OE from the drive mech falls
   // PB3 is output enable, PB2 is start strobe
   TSR3 &= 0xFD;
   cd_mech_return_method = 0;
   r1 = cd_mech_bytes & 0x7F;

   if (!(cd_mech_bytes & 0x7F))
   {
      // start of new transfer(loc_97CE)

      // backup register R4-R13, PR, GBR, MACH/MACL
      // save stack to running_task[tcb.saved_sp]
      // set stack to 0xF0008F8
      cd_mech_return_method = 1;

      if (PBDR & 0x4)
      {
         // 9828
         cd_mech_bytes = 0x80;
         //goto 9794
      }
      else
      {
         // 9802
         if (cd_mech_bytes == 0)
         {
            // 980A
            if (unk_F0002C4[11] == 0)
            {
               // 9832
               memset(cd_mech_buff, 0, 11);
               cd_mech_buff[11] = 0xFF;
            }
            else
            {
               // 9832
               memcpy(cd_mech_buff, unk_F0002C4, 12);
               u8 chksum = cd_mech_buff[0];
               for (i = 1; i < 11; i++)
                  chksum = cd_mech_buff[i];
               cd_mech_buff[11] = ~chksum;
               unk_F0002C4[11] = 0;
            }
         }

         // 981E
         TRANSFER_STATUS = 0; // clears rx packet ok flag
         cd_mech_csum2 = 0; // clears csum
      }
   }
   // old transfer
   else if (PBDR & 0x4)
       goto 9768;

   //97ca reset the byte count
   cd_mech_bytes = 0; //mov #0, r1
 
   //9768
   cd_mech_bytes++; //add #1, r1 , mov r1, r0 , mov.b r0, @(0xd, r3)
   
   // Is upcoming data parity byte(number 13 is somewhat deceiving)
   if (cd_mech_bytes == 13) //cmp/eq #13, r0
   {
      //97ac
      u8 received_data = RDR0;//mov.b @((RDR0 - SMR0), gbr), r0
      received_data = ~received_data; //97ae invert checksum
 
      u8 data_to_transmit;
      //97B2 make sure checksum matches calculated checksum
      if (received_data != cd_mech_csum)
      {
         //97c6
         // checksum failure
         data_to_transmit = 1;
      }
      else
      {
         //97b6
         // checksum is good
         TRANSFER_STATUS = 1;
         data_to_transmit = 0;
      }
 
      //97be
      TDR0 = data_to_transmit;
      SSR0 |= 0x40;
   }
   else
   {
      //9776
      u8 to_transmit = cd_mech_buff[cd_mech_bytes-1];//mov r3, r2. add #-1, r2. mov.b @(r0, r2), r0
      TDR0 = to_transmit;//mov.b r0, @((TDR0 - SMR0), gbr)
 
      if (cd_mech_bytes != 1)//cmp/eq #1, r0
      {   //9784
         u8 received_data = RDR0;
         *((u8 *)cd_rx)[cd_mech_bytes-2] = received_data; // even though this is referenced as F0002CE, 
                                                          // it really end up being cd_rx_status since 
                                                          // cd_mech_bytes >= 2
         cd_mech_csum += received_data;
      }
   }
 
   //97be, 9784, 9776 and 9828 all come here
   SSR0 = 0;//9794
 
   if (cd_mech_return_method != 0)//cmp/eq #0, r0
   {
      //9876
      next_task(); //mov.l #schedule_running_task, r1, jmp @r1
   }
   else
      return;//979e
}

//task6

#define YGR_CR1_REG (*(u16*)(0xA000010))
#define YGR_CR2_REG (*(u16*)(0xA000012))
#define YGR_CR3_REG (*(u16*)(0xA000014))
#define YGR_CR4_REG (*(u16*)(0xA000016))

#define YGR_HIRQ_REG (*(u16*)(0xA00001E))
#define YGR_1A_REG (*(u16*)(0xA00001A))
#define UNKN (*(u8*)(0xf000894))
#define UNKN2 (*(u8*)(0xf0002A6))
#define PBDR_L (*(u8*)(0x5FFFFC3))//lower byte of pbdr
#define AUTH_BUSY (*(u8*)(0xf0007b0))

#define CR_BUFFER ((u8*)(0x0F00026C))

void loc_2914()
{
   //PB6, pin 104, deemphasis output
   //low == demp off
   //high == demp on
   PBDR_L &= 0xBF;
}

void loc_28b0()
{
   if (UNKN & 0x10)
   {
      //28dc
      YGR_1A_REG &= 0xffef;

      if (UNKN2 & 0x28)//gbr == 0xf00025c
      {
         goto loc_2920;
      }
      else
      {
         //28ee
         if (cd_stat == 6)
         {
loc_28f8:
            //28f8
            //0x4 means reading?
            //readtoc == 0x4
            //readdata == 0x36 (0x4 is set)
            //readaudio == 0x34
            if(cd_rx.status & 0x4)//F0002D0
               goto loc_2920;
            else
            {
               if (cd_stat == 0)
               {
                  goto loc_2920;
               }
               else
               {
                  //subcode q data has preemphasis set?
                  //turn deemphasis pin on or off
                  if (cd_rx.q & 0x10)//F0002D1
                     goto loc_2914;
                  else
                     goto loc_290a;
               }
            }


         }
         else
         {
            //28f4
            if (cd_stat == 0xc)
               goto loc_2914;
            else
               goto loc_28f8;
         }
      }
   }
   else
   {
      //28c0
      YGR_1A_REG |= 0x10;

      if (UNKN & 0x80)
      {
         //290a
         PBDR_L |= 0x40;//PB6
         goto loc_291c;
      }
      else
      {
         //28d2
         loc_2914();
         goto loc_291c;
      }
   } 

   u16 cr1, cr2, cr3, cr4;
loc_291c:
   //reload gbr with cd stat
loc_2920:
   if (AUTH_BUSY & 1)
   {
      //2932

      if (cd_stat != 0)//2938
      {
         //use the second cr response
         cr1 = CR_BUFFER[4];
         cr2 = CR_BUFFER[5];
         cr3 = CR_BUFFER[6];
         cr4 = CR_BUFFER[7];
      }
      else
      {
         cr1 = CR_BUFFER[0];
         cr2 = CR_BUFFER[1];
         cr3 = CR_BUFFER[2];
         cr4 = CR_BUFFER[3];
      }

      cr1 |= 0x2000;//periodic
   }
   else
   {
      //2928
      cr1 = 0x20ff;
      cr2 = 0xffff;
      cr3 = 0xffff;
      cr4 = 0xffff;
   }

loc_296a:
   if (mbx_stat & 2)
   {
      //2982
      YGR_CR1_REG = cr1;
      YGR_CR2_REG = cr2;
      YGR_CR3_REG = cr3;
      YGR_CR4_REG = cr4;
   }

   //298a
   YGR_HIRQ_REG |= 0x400;

   wait();//2994
}
